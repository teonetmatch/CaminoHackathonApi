// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: cmp/types/v1/price.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Cmp.Types.V1 {

  /// <summary>Holder for reflection information generated from cmp/types/v1/price.proto</summary>
  public static partial class PriceReflection {

    #region Descriptor
    /// <summary>File descriptor for cmp/types/v1/price.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static PriceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChhjbXAvdHlwZXMvdjEvcHJpY2UucHJvdG8SDGNtcC50eXBlcy52MRobY21w",
            "L3R5cGVzL3YxL2N1cnJlbmN5LnByb3RvGh1jbXAvdHlwZXMvdjEvcHJpY2Vf",
            "dHlwZS5wcm90byLPAQoLUHJpY2VEZXRhaWwSIgoFcHJpY2UYASABKAsyEy5j",
            "bXAudHlwZXMudjEuUHJpY2USDwoHYmluZGluZxgCIAEoCBITCgtkZXNjcmlw",
            "dGlvbhgDIAEoCRIXCg9sb2NhbGx5X3BheWFibGUYBCABKAgSLgoEdHlwZRgF",
            "IAEoCzIgLmNtcC50eXBlcy52MS5QcmljZUJyZWFrZG93blR5cGUSLQoKYnJl",
            "YWtkb3ducxgGIAMoCzIZLmNtcC50eXBlcy52MS5QcmljZURldGFpbCJSCgVQ",
            "cmljZRINCgV2YWx1ZRgBIAEoCRIQCghkZWNpbWFscxgCIAEoBRIoCghjdXJy",
            "ZW5jeRgDIAEoCzIWLmNtcC50eXBlcy52MS5DdXJyZW5jeWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Cmp.Types.V1.CurrencyReflection.Descriptor, global::Cmp.Types.V1.PriceTypeReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Cmp.Types.V1.PriceDetail), global::Cmp.Types.V1.PriceDetail.Parser, new[]{ "Price", "Binding", "Description", "LocallyPayable", "Type", "Breakdowns" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Cmp.Types.V1.Price), global::Cmp.Types.V1.Price.Parser, new[]{ "Value", "Decimals", "Currency" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// ### PriceDetail
  ///
  /// This message consists of the value as a Price object and additional fields as
  /// binding, concept, and breakdown.
  ///
  /// Breakdown is a recursively inherited object of PriceDetail. This way complex
  /// pricing structures can be represented.
  ///
  /// ![Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v1/price.proto.dot.xs.svg)
  ///
  /// [Open Message Diagram](https://storage.googleapis.com/docs-cmp-files/diagrams/proto/cmp/types/v1/price.proto.dot.svg)
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class PriceDetail : pb::IMessage<PriceDetail>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<PriceDetail> _parser = new pb::MessageParser<PriceDetail>(() => new PriceDetail());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<PriceDetail> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Cmp.Types.V1.PriceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PriceDetail() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PriceDetail(PriceDetail other) : this() {
      price_ = other.price_ != null ? other.price_.Clone() : null;
      binding_ = other.binding_;
      description_ = other.description_;
      locallyPayable_ = other.locallyPayable_;
      type_ = other.type_ != null ? other.type_.Clone() : null;
      breakdowns_ = other.breakdowns_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public PriceDetail Clone() {
      return new PriceDetail(this);
    }

    /// <summary>Field number for the "price" field.</summary>
    public const int PriceFieldNumber = 1;
    private global::Cmp.Types.V1.Price price_;
    /// <summary>
    /// Principle price element
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cmp.Types.V1.Price Price {
      get { return price_; }
      set {
        price_ = value;
      }
    }

    /// <summary>Field number for the "binding" field.</summary>
    public const int BindingFieldNumber = 2;
    private bool binding_;
    /// <summary>
    /// Identification whether the price must be respected towards the end-user
    /// and the product or service cannot be offered for a lower price.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Binding {
      get { return binding_; }
      set {
        binding_ = value;
      }
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 3;
    private string description_ = "";
    /// <summary>
    /// Description of the product or service this price(element) is valid for.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Description {
      get { return description_; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "locally_payable" field.</summary>
    public const int LocallyPayableFieldNumber = 4;
    private bool locallyPayable_;
    /// <summary>
    /// If not specified, the default of the boolean is false which means it is
    /// included in the price. If set to True, it means that this PriceDetail is only
    /// payable locally. For example local tourism tax that you pay at the reception of
    /// a hotel. Intended to be used in the breakdown.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool LocallyPayable {
      get { return locallyPayable_; }
      set {
        locallyPayable_ = value;
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 5;
    private global::Cmp.Types.V1.PriceBreakdownType type_;
    /// <summary>
    /// Type of price breakdown. This is meant to be used in price breakdown
    /// definitions, when we want to specify the different elements of how a total
    /// price was computed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cmp.Types.V1.PriceBreakdownType Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "breakdowns" field.</summary>
    public const int BreakdownsFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Cmp.Types.V1.PriceDetail> _repeated_breakdowns_codec
        = pb::FieldCodec.ForMessage(50, global::Cmp.Types.V1.PriceDetail.Parser);
    private readonly pbc::RepeatedField<global::Cmp.Types.V1.PriceDetail> breakdowns_ = new pbc::RepeatedField<global::Cmp.Types.V1.PriceDetail>();
    /// <summary>
    /// We can use a single PriceDetail to represent a price breakdown.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::Cmp.Types.V1.PriceDetail> Breakdowns {
      get { return breakdowns_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as PriceDetail);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(PriceDetail other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Price, other.Price)) return false;
      if (Binding != other.Binding) return false;
      if (Description != other.Description) return false;
      if (LocallyPayable != other.LocallyPayable) return false;
      if (!object.Equals(Type, other.Type)) return false;
      if(!breakdowns_.Equals(other.breakdowns_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (price_ != null) hash ^= Price.GetHashCode();
      if (Binding != false) hash ^= Binding.GetHashCode();
      if (Description.Length != 0) hash ^= Description.GetHashCode();
      if (LocallyPayable != false) hash ^= LocallyPayable.GetHashCode();
      if (type_ != null) hash ^= Type.GetHashCode();
      hash ^= breakdowns_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (price_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Price);
      }
      if (Binding != false) {
        output.WriteRawTag(16);
        output.WriteBool(Binding);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Description);
      }
      if (LocallyPayable != false) {
        output.WriteRawTag(32);
        output.WriteBool(LocallyPayable);
      }
      if (type_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Type);
      }
      breakdowns_.WriteTo(output, _repeated_breakdowns_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (price_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Price);
      }
      if (Binding != false) {
        output.WriteRawTag(16);
        output.WriteBool(Binding);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Description);
      }
      if (LocallyPayable != false) {
        output.WriteRawTag(32);
        output.WriteBool(LocallyPayable);
      }
      if (type_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Type);
      }
      breakdowns_.WriteTo(ref output, _repeated_breakdowns_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (price_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Price);
      }
      if (Binding != false) {
        size += 1 + 1;
      }
      if (Description.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (LocallyPayable != false) {
        size += 1 + 1;
      }
      if (type_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Type);
      }
      size += breakdowns_.CalculateSize(_repeated_breakdowns_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(PriceDetail other) {
      if (other == null) {
        return;
      }
      if (other.price_ != null) {
        if (price_ == null) {
          Price = new global::Cmp.Types.V1.Price();
        }
        Price.MergeFrom(other.Price);
      }
      if (other.Binding != false) {
        Binding = other.Binding;
      }
      if (other.Description.Length != 0) {
        Description = other.Description;
      }
      if (other.LocallyPayable != false) {
        LocallyPayable = other.LocallyPayable;
      }
      if (other.type_ != null) {
        if (type_ == null) {
          Type = new global::Cmp.Types.V1.PriceBreakdownType();
        }
        Type.MergeFrom(other.Type);
      }
      breakdowns_.Add(other.breakdowns_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (price_ == null) {
              Price = new global::Cmp.Types.V1.Price();
            }
            input.ReadMessage(Price);
            break;
          }
          case 16: {
            Binding = input.ReadBool();
            break;
          }
          case 26: {
            Description = input.ReadString();
            break;
          }
          case 32: {
            LocallyPayable = input.ReadBool();
            break;
          }
          case 42: {
            if (type_ == null) {
              Type = new global::Cmp.Types.V1.PriceBreakdownType();
            }
            input.ReadMessage(Type);
            break;
          }
          case 50: {
            breakdowns_.AddEntriesFrom(input, _repeated_breakdowns_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (price_ == null) {
              Price = new global::Cmp.Types.V1.Price();
            }
            input.ReadMessage(Price);
            break;
          }
          case 16: {
            Binding = input.ReadBool();
            break;
          }
          case 26: {
            Description = input.ReadString();
            break;
          }
          case 32: {
            LocallyPayable = input.ReadBool();
            break;
          }
          case 42: {
            if (type_ == null) {
              Type = new global::Cmp.Types.V1.PriceBreakdownType();
            }
            input.ReadMessage(Type);
            break;
          }
          case 50: {
            breakdowns_.AddEntriesFrom(ref input, _repeated_breakdowns_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ### Simple Price type message Price
  ///
  /// Value of the price, this should be an integer converted to string.
  ///
  /// This field is a string intentionally. Because the currency can be a crypto
  /// currency, we need a reliable way to represent big integers as most of the crypto
  /// currencies have 18 decimals precision.
  ///
  /// Definition of the price message: The combination of "value" and "decimals" fields
  /// express always the value of the currency, not of the fraction of the currency [
  /// ETH not wei, CAM and not aCAM, BTC and not Satoshi, EUR not EUR-Cents ] Be aware
  /// that partners should not do rounding with crypto currencies.
  ///
  /// Example implementations: off-chain payment of 100 € or 100 $: value=10000
  /// decimals=2 iso_currency=EUR or USD
  ///
  /// On-chain payment of 100.65 EURSH value=10065 decimals=2 contract_address=0x...
  ///  this currency has 5 decimals on Columbus and conclusively to create the
  ///  transaction value, 10065 must be divided by 10^2 = 100.65 EURSH and created in
  ///  its smallest fraction by multiplying  100.65 EURSH * 10^5 => 10065000 (example
  ///  conversion to bigint without losing accuracy: bigint(10065) * 10^(5-2))
  ///
  /// On-chain payment of 0.0065 BTC value=65 decimals=4 contract_address=0x... Using
  ///  the contract address, we get the decimals decimals and the currency name or
  ///  abbreviation: 8 decimals &amp; WBTC Because we see 4 decimals specified in the
  ///  message we divide 65 by 10^4 == 0.0065 WBTC (for showing in the front-end UIs)
  ///
  ///  This currency has 8 decimals on-chain and conclusively to use the value of
  ///  0.0065 for on-chain operations must be converted to big integer as bigint(65) *
  ///  10^(8-4) == 650000
  ///
  /// On-chain payment of 1 nCAM value=1 decimals=9 this currency has denominator 18 on
  ///  Columbus and conclusively to mint the value of 1 nCam must be divided by 10^9 =
  ///  0.000000001 CAM and minted in its smallest fraction by multiplying 0.000000001 *
  ///  10^18 => 1000000000 aCAM
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Price : pb::IMessage<Price>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Price> _parser = new pb::MessageParser<Price>(() => new Price());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Price> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Cmp.Types.V1.PriceReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Price() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Price(Price other) : this() {
      value_ = other.value_;
      decimals_ = other.decimals_;
      currency_ = other.currency_ != null ? other.currency_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Price Clone() {
      return new Price(this);
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 1;
    private string value_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Value {
      get { return value_; }
      set {
        value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "decimals" field.</summary>
    public const int DecimalsFieldNumber = 2;
    private int decimals_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Decimals {
      get { return decimals_; }
      set {
        decimals_ = value;
      }
    }

    /// <summary>Field number for the "currency" field.</summary>
    public const int CurrencyFieldNumber = 3;
    private global::Cmp.Types.V1.Currency currency_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::Cmp.Types.V1.Currency Currency {
      get { return currency_; }
      set {
        currency_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Price);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Price other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Value != other.Value) return false;
      if (Decimals != other.Decimals) return false;
      if (!object.Equals(Currency, other.Currency)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Value.Length != 0) hash ^= Value.GetHashCode();
      if (Decimals != 0) hash ^= Decimals.GetHashCode();
      if (currency_ != null) hash ^= Currency.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Value.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Value);
      }
      if (Decimals != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Decimals);
      }
      if (currency_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Currency);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Value.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Value);
      }
      if (Decimals != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Decimals);
      }
      if (currency_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Currency);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Value.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Value);
      }
      if (Decimals != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Decimals);
      }
      if (currency_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Currency);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Price other) {
      if (other == null) {
        return;
      }
      if (other.Value.Length != 0) {
        Value = other.Value;
      }
      if (other.Decimals != 0) {
        Decimals = other.Decimals;
      }
      if (other.currency_ != null) {
        if (currency_ == null) {
          Currency = new global::Cmp.Types.V1.Currency();
        }
        Currency.MergeFrom(other.Currency);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Value = input.ReadString();
            break;
          }
          case 16: {
            Decimals = input.ReadInt32();
            break;
          }
          case 26: {
            if (currency_ == null) {
              Currency = new global::Cmp.Types.V1.Currency();
            }
            input.ReadMessage(Currency);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Value = input.ReadString();
            break;
          }
          case 16: {
            Decimals = input.ReadInt32();
            break;
          }
          case 26: {
            if (currency_ == null) {
              Currency = new global::Cmp.Types.V1.Currency();
            }
            input.ReadMessage(Currency);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
